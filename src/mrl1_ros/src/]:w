#ifndef MOTOR_CONTROL_HPP_
#define MOTOR_CONTROL_HPP_


#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Float64.h"
#include "sensor_msgs/LaserScan.h"
#include "std_msgs/Float64.h"
#include "ProcessLaserScan.hpp"


#include <sstream>
#include <vector>
#include <iostream>


class motorControl{

    public:

       
        ros::NodeHandle nh_;
        ros::Subscriber scanSub_;
        ros::Publisher leftWheelPub_;
        ros::Publisher rightWheelPub_;
       
        std::vector<float> rangeReadings;
	    std::vector<float> angleReadings;
	
        std_msgs::Float64 leftEffort;
        std_msgs::Float64 rightEffort;
     
        int i;

        motorControl(ros::NodeHandle& nh,std::string laserTopic, std::string leftwheelcontrollertopic, std::string rightwheelcontrollertopic)
        {
            nh_ = nh;
            i=1;    
            // scanSub_ = nh_.subscribe<sensor_msgs::LaserScan>(laserTopic, 1000, &motorControl::controlCb,this); // do I need to spin here?
             scanSub_ = nh_.subscribe<sensor_msgs::LaserScan>(laserTopic, 1000, &motorControl::controlCb,this); // do I need to spin here?
            

           // std::cout<< rangeReadings.at(2)<<std::endl;

            leftWheelPub_ = nh_.advertise<std_msgs::Float64>(leftwheelcontrollertopic, 1000);
            rightWheelPub_ = nh_.advertise<std_msgs::Float64>(rightwheelcontrollertopic, 1000);  
            
        }

        ~motorControl(void)
        {
        }

	void controlCb(const sensor_msgs::LaserScan::ConstPtr& Lscan_msg)
	{
		rangeReadings.clear();
		angleReadings.clear();
	  size_t num_ranges = Lscan_msg->ranges.size();
	  int x;
	 
	 angleReadings.push_back(Lscan_msg->angle_min); //push the angle (in radians) of each ray into the vector
	 
	 
	  for (x = 0; x <= num_ranges; x++)
	   {
		   
		rangeReadings.push_back(Lscan_msg->ranges[x]);
		angleReadings.push_back(angleReadings.back()+Lscan_msg->angle_increment);
		
		}
		angleReadings.pop_back();

       leftEffort.data = 1.2+i;
          
	     // leftEffort.data = 0;
         // rightEffort.data = 0;

         // leftWheelPub_.publish(leftEffort);
         // rightWheelPub_.publish(rightEffort);
           

	} 


    void spin()
    {
         ros::Rate loop_rate(10);

                 int count = 0;
                 //while (ros::ok())
                while (nh_.ok())
                { 

                     ros::spinOnce();
                     loop_rate.sleep();
                      ++count;

                }
 

    }

    void motorController()
    {
       // std::cout<< rangeReadings.size()<<std::endl;
        std::cout<<leftEffort.data<<std::endl;
    }
};

#endif

















